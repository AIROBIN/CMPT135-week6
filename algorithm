#include<iostream>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;

class Money{
private:
	int cents,dollars;
public:
	Money(){cents=dollars=0;}   //Default constructor; sets cents and dollars to zero
	Money(const int &c, const int &d){cents=c;dollars=d;}    //Non-default constructor; sets cents to c and dollars to d
	Money(const Money &m){cents=m.cents;dollars=m.dollars;} //Copy constructor, copies cents and dollars of m to cents and dollars
	int getCents() const{return cents;}//getter function to get cents
	int getDollars() const{return dollars;} //getter function to get the dollars
	void setCents(const int &c){cents=c;} //sets the cents to c
	void setDollars(const int &d){dollars=d;} //sets the dollars to d
	string toString() const //other member function to return money as $DOLLARS.CENTS
	{
		int count1=0,count2=0;
		int d=dollars,c=cents;
		while(d!=0){d/=10;count1++;}   //328
		while(c!=0){c/=10;count2++;}
		d=dollars,c=cents;
		char* s=new char[count1+count2+3];
		s[0]='$';
		for(int i=count1;i>0;i--)
		{
			s[i]=d%10+'0';
			d/=10;
		}
		s[count1+1]=',';
		for(int i=count2;i>0;i--)
		{
			s[count1+1+i]=c%10+'0';
			c/=10;
		}
		s[count1+count2+2]='\0';
		return s;
	}

	float amount()const{return dollars+1.0*cents/100;} //other member function to return dollars + (float(cents)/100)
	Money operator + (const Money &m) const{return Money(cents+m.cents,dollars+m.dollars);}//addition operator (add two Money objects)
	Money operator - (const Money &m) const{return Money(cents-m.cents,dollars-m.dollars);}    //subtraction operator (subtract Money object from another)
	Money& operator = (const Money &m){cents=m.cents;dollars=m.dollars;return *this;}//Assignment operator (assign Money object to another)
	bool operator == (const Money &m) const{return (cents==m.cents&&dollars==m.dollars);}//equality test member operator
	bool operator != (const Money &m) const{return !(*this==m);}//Inequality test member operator
	bool operator > (const Money &m) const{
		if(dollars>m.dollars)
			return true;
		else if(dollars==m.dollars&&cents>m.cents)
			return true;
		else
			return false;
	}
	bool operator >= (const Money &m) const{return (*this>m)||(*this==m);}//Greater than or equal to test member operator
	bool operator < (const Money &m) const{return !(*this>=m);} //Less than test member operator
	bool operator <= (const Money &m) const{return !(*this>m);}//Less than or equal to test member operator
	friend ostream& operator<<(ostream &outputStream, const Money &m){
		outputStream<<m.dollars<<"."<<m.cents<<endl;
		return outputStream;
	}
};


	int stringtoint(char*str)
	{
		int i=0,result=0;
		if(str[0]=='-')
			i++;
		while(str[i]!='\0')
		{	
			result=result*10+(str[i]-'0');
			i++;
		}
		if(str[0]=='-')
			result*=-1;
		return result;
	}
		
int  countDistinctChars(char *s)
{
	int L=0;
	while(s[L]!='\0')
		L++;
	int c[26]={0};
	for(int i=0;i<L;i++)
		c[s[i]-'a']++;
	int count=0;
	for(int i=0;i<26;i++)
		if(c[i]>0)
			count++;
	return count;
}
//	
//int gcd(int a,int b){
//	return b==0?a:gcd(b,a%b);}
//
//int a,b;
//while(b>0)
//{
//	int t=a%b;a=b;b=t;}
//num/=a;denom/=a;


//在【100,999】的范围内找出所以满足以下条件的数并输出 
//1. 这个数是一个完全平方数 
//2. 这个数中某个数字出现的次数大于1次
int* countEachNumber(int n)
{
	int* exist=new int[10]();
	while(n!=0)
	{
		exist[n%10]++;
		n/=10;
	}
	return exist;
}
void printALL1()
{
	int temp,a,b,c;
	for(int i=10;i<=31;i++)
	{
		temp=i*i;
		c=temp%10;
		b=temp/10%10;
		a=temp/100;
		if(a==b||b==c||a==c)
			cout<<temp<<" ";
	}
}
void printALL2()
{
	int temp;
	for(int i=10;i<=31;i++)
	{
		int exist[10]={0};
		temp=i*i;
	//	bool check=false;
		while(temp)
		{
			exist[temp%10]++;
			if(exist[temp%10]>1)
			{
				cout<<i*i<<" ";
				break;
			}
			temp/=10;
		}
		//if(check)
	//		cout<<i*i<<" ";
	}
}

void print2()  //7744
{
	int temp;
	for(int i=32;i<100;i++)
	{
		temp=i*i;
		int exist[10]={0};
		int count=0;
		while(temp)
		{
			exist[temp%10]++;
			if(exist[temp%10]==2)
				count++;
			if(count==2)
			{	
				cout<<i*i<<" ";
				break;
			}
			temp/=10;
		}
	}
}
bool isSquare(const int& n)
{
	int m=n;
	//all All perfect squares are sums of consecutive odd numbers
	// 1 = 1
	// 4 = 1 + 3
	// 9 = 1 + 3 + 5
	// 16 = 1 + 3 + 5 + 7
	/*for(int i=1;m>0;i+=2)
		m-=i;
	return m==0;*/
	int root = (int)(sqrtf(m) + 0.5);
	return root*root==n;
	//return (sqrtf(n))%1==sqrtf(n);
}
int squareroot(const int&n)    //binary search   O(log n)    used in array or order permutation
{
	int left=0,right=n;  
	int mid; //long long   prevent overflow
	while(left<=right){
		mid=left+((right-left)>>1);
		if(mid*mid>n)
			right=mid-1;
		else if(mid*mid<n)
			left=mid+1;
		else
			return mid;
	}
	if(left*left>n)
		return left-1;
	return left;
}
bool isPrime(int n)
{
	if(n==1)
		return false;
	int sqr=(int)sqrt(n*1.0);
	for(int i=2;i<=sqr;i++)
		if(n%i==0)
			return false;
	return true;
}



//Anytime minimize the number of cycles and the range of i, making time complexity maximum
int main()
{
	//Money m(345,678);
	//cout<<m.toString();
	/*cout<<isSpecialSquare(7744);
	cout<<isSpecialSquare(100);
	cout<<isSpecialSquare(121);
	cout<<isSpecialSquare(99999);
	cout<<isSpecialSquare(529);*/
	//printALL1();
	//printALL2();
	//print2();


	//int A[5]={0,1,999,225,-9};
	//for(int i=0;i<5;i++)
	//	cout<<isSquare(A[i])<<" ";

	int x;//1:2:3
	for(x=123;3*x<=987;x++)
	{
		int exist[10]={0};
		int count=0;
		for(int i=1;i<=3;i++)
		{	
			exist[i*x%10]++;
			exist[i*x/10%10]++;
			exist[i*x/100]++;
		}
		/*while(x>0)
		{
			exist[x%10]++;
			x/=10;
		}*/
		for(int j=1;j<=9;j++)
			if(exist[j]==1)
				count++;
		if(count==9)
			cout<<x<<" "<<2*x<<" "<<3*x<<endl;
	}

		
	
		
	

	



	
	system("Pause");
	return 0;
}


